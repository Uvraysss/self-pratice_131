Self-practice
Week 02
In class

let students = { stdno:67130500131, Fisrtname: "Thunwawee", 
Lastname: "Nithiphornchaiwong" }
console.log(students) 

คำอธิบาย เป็นการสร้าง Object students ที่มี 3 key คือ stdno, Fisrtname, Lastname เมื่อ console.log(students)
ออกมา จะได้ผลลัพธ์ออกมาเป็น {stdno: 67130500131, Fisrtname: 'Thunwawee', Lastname: 'Nithiphornchaiwong'}

------------------------------------------------------------------------------------------------------

const book = {isbn:12345678, title:'Introduction to JS',
authors:[{firstname:'John'}, {lastname:'Smith'},
{firstname:'Danial'}, {lastname:'Doh'}, {firstname:'YOU'}, {lastname:'Nithi'}], 
versions:[1.0, 2.0,3.0], isAvailable:true, getISBN(){return this.isbn},isbn:67130500131} 
console.log(book)
console.log(book.getISBN())
console.log(book.authors[0].firstname)
console.log(book.authors) //array
console.log(Object.values(book.authors))

คำอธิบาย เป็นการสร้าง Object book ที่มี 6 key คือ isbn, title, authors, versions, isAvailable และ getISBN
ซึ่ง แสดงให้เห็นว่าเราสามารถสร้าง Array ใน Object ได้ หรือจะสร้าง Object ซ้อน Object ก็ได้ และได้แสดงให้เห็นว่าถ้ากำหนด 
key ซ้ำกัน เช่น isbn:12345678 และ isbn:67130500131 เมื่อรันโปรแกรมออกมา จะได้ผลลัพธ์เป็น value ล่าสุดคือ 67130500131
รวมผลลัพธ์ที่แสดงได้เป็นดังนี้ : 
console.log(book) --> {
  isbn: 67130500131,
  title: 'Introduction to JS',
  authors: [
    { firstname: 'John' },
    { lastname: 'Smith' },
    { firstname: 'Danial' },
    { lastname: 'Doh' },
    { firstname: 'YOU' },
    { lastname: 'Nithi' }
  ],
  versions: [ 1, 2, 3 ],
  isAvailable: true,
  getISBN: [Function: getISBN]
}
console.log(book.getISBN()) --> 67130500131
console.log(book.authors[0].firstname) --> John
console.log(book.authors) และ console.log(Object.values(book.authors)) --> [
  { firstname: 'John' },
  { lastname: 'Smith' },
  { firstname: 'Danial' },
  { lastname: 'Doh' },
  { firstname: 'YOU' },
  { lastname: 'Nithi' }
]

------------------------------------------------------------------------------------------------------

book.publishDate = new Date(2025, 1, 10) // Add key เพิ่มใน Object book
console.log(book)
delete book.isAvailable // ลบ key isAvailable ออกจาก Object book
console.log(book)
console.log(book["publishDate"])
console.log(book.publishDate)

for (const key in book) {
    console.log(book[key])
} 

คำอธิบาย book.publishDate = new Date(2025, 1, 10) เป็นการเพิ่ม key publishDate ลงใน Object book 
ต่อมาเป็นคำสั่ง delete book.isAvailable เป็นการลบ key isAvailable ออกจาก Object book เมื่อ console.log(book)
ออกมา จะได้ผลลัพธ์เป็น {
  isbn: 67130500131,
  title: 'Introduction to JS',
  authors: [
    { firstname: 'John' },
    { lastname: 'Smith' },
    { firstname: 'Danial' },
    { lastname: 'Doh' },
    { firstname: 'YOU' },
    { lastname: 'Nithi' }
  ],
  versions: [ 1, 2, 3 ],
  getISBN: [Function: getISBN],
  publishDate: 2025-02-09T17:00:00.000Z
}
console.log(book["publishDate"]) และ console.log(book.publishDate) --> 2025-02-09T17:00:00.000Z
และนอกจากนี้ยังมีการใช้ for loop เพื่อวนลูปค่าใน Object book อีกด้วย ซึ่งได้ผลลัพธ์เป็น: 
67130500131
Introduction to JS
[
  { firstname: 'John' },
  { lastname: 'Smith' },
  { firstname: 'Danial' },
  { lastname: 'Doh' },
  { firstname: 'YOU' },
  { lastname: 'Nithi' }
]
[ 1, 2, 3 ]
[Function: getISBN]
2025-02-09T17:00:00.000Z

------------------------------------------------------------------------------------------------------

//constructure Function
function Book(isbn, title) { // ฺB ตัวใหญ่ สังเกตว่าเป็น constructure function
    this.isbn = isbn
    this.title = title
} // ฺสังเกตว่าใช้ this เป็นการเขียนแบบ consturcture function 

const myBook = new Book (111,"JS") // myBook เป็น Object ที่เก็บ reference หรือ เก็บ Address ที่พาไปหาตัว Object ที่แท้จริง หรือ Book
const b1 = new Book (123, "HTML")
const b2 = new Book (134, "CSS")
console.log(myBook)

คำอธิบาย ตัวอย่างของการสร้าง Object แบบ constructure function มีข้อสังเกตคือ ขึ้นต้นชื่อ function ใช้เป็นตัวอักษรใหญ่ และ
มีการใช้ this. เป็นการเขียนแบบ constructure function การกำหนด const myBook = new Book (111,"JS") เป็นการสร้าง 
Object ที่เก็บ reference หรือ เก็บ Address ที่พาไปหาตัว Object ที่แท้จริง หรือ Book ได้ เมื่อ console.log(myBook) ออกมา
จะได้ผลลัพธ์เป็น Book { isbn: 111, title: 'JS' } 

----------------------------------------------------------------------------------------------------------

// Class
class Book{
    constructor(isbn, title){
        this.isbn=isbn
        this.title=title
    }
    getISBN(){ 
        return this.isbn
    }
    setTitle(title){
        this.title=title
    }
    getBookInfo(){
        return `isbn: ${this.isbn}, title: ${this.title}`
    }
}
const Book1 = new Book(12345678, 'JS Beginner')
console.log(Book1.getBookInfo())
console.log(Book1.getISBN())
Book1.setTitle('JS for Beginner')
console.log(Book1.getBookInfo())

คำอธิบาย ตัวอย่างของการสร้าง Object แบบใช้ ES6 Class มีการใส่ method ต่าง ๆ ใน class ด้วย เช่น getISBN() คือ
method ดึงค่า isbn setTitle(title) method ตั้งค่า title ใหม่ และ getBookInfo() method แสดงข้อมูลรวม Book1 คือ
การสร้าง Object ที่เก็บ reference หรือ เก็บ Address ที่พาไปหาตัว Object ที่แท้จริง หรือ Book เมื่อ console.log(Book1.getBookInfo()) 
ออกมา จะได้ผลลัพธ์เป็น isbn: 12345678, title: JS Beginner ต่อมา console.log(Book1.getISBN()) ได้ค่าเป็น 12345678
Book1.setTitle('JS for Beginner') เป็นการเปลี่ยนค่า title เมื่อ console.log(Book1.getBookInfo()) ออกมาอีกครั้ง
จะได้ค่าเป็น isbn: 12345678, title: JS for Beginner

---------------------------------------------------------------------------------------------------------------------

// using Object.create(existingObj)
const journal=Object.create(myBook)
journal.ISSN=587904
console.log(journal)
console.log(journal.isbn)
console.log(journal.title)

const y = {id:1, title:"JS"}
function doSomething(x){
    x = {id:1, title:"JS"} // x ฉีกออกมาสร้าง Object ใหม่แล้ว ไม่เกี่ยวกับ Object y
    x.id = 555
}
console.log(y)
console.log(doSomething(y))
console.log(y)

คำอธิบาย Object.create(myBook) เป็นการสร้าง Object journal โดยมี prototype เชื่อมไปยัง myBook และเพิ่ม property 
ใหม่ ISSN ให้ journal เวลาเรียกหา property ถ้า journal ไม่มี จะไปหาใน prototype myBook แทน ต่อมาเรียก
function doSomething(y) ซึ่งค่าของ y ถูกส่งเข้าไป (reference) แต่ในฟังก์ชัน x = {id:1, title:"JS"} ทำให้ x 
ชี้ไปยัง object ใหม่ เลย ไม่เกี่ยวข้องกับ y เดิมแล้ว เมื่อ console.log(y) ออกมาใหม่ จึงได้ค่า { id: 1, title: 'JS' } เหมือนเดิม 

---------------------------------------------------------------------------------------------------------------------

const y1 = {id:1, title:"JS"}
const y2 = {id:2, title:"JS"}
console.log(y1==y2)
console.log(y1===y2)
// false เนื่องจากเป็น Object คนละตัวกัน Memory Address ต่างกัน
console.log(Object.is(y1,y2))

y1 = y2 // เนื่องจาก b2 ให้ references จะกลายเป็นอยู่ที่เดียวกันแล้วจึงเป็น true
console.log(y1==y2)
console.log(y1===y2)
console.log(Object.is(y1,y2))

const x1={isbn:123, title:"JS"}
const x2={isbn:123, title:"JS"}
function isBookEqual(book1,book2) {
    if (book1.isbn === book2.isbn) {
        return true
    } else false
}
console.log(isBookEqual(x1,x2))

คำอธิบาย ตัวอย่างการเปรียบเทียบความเท่ากันของ Object โดย y1 และ y2 แม้จะมีค่า property คล้ายกัน แต่เป็น object 
คนละตัว อยู่ คนละ Memory Address ดังนั้น การเปรียบเทียบ (==, ===, Object.is) --> false ทุกกรณี แต่หลังจากกำนหดให้
y1 = y2 แล้ว ทั้ง 2 ชี้ไปที่ object เดียวกันใน Memory Address จึงได้ค่าเป็น true ทุกกรณี ต่อมามีการสร้าง function isBookEqual
เพื่อตรวจสอบว่าค่า isbn ของ book1 และ book2 เท่ากันหรือไม่ จึงสร้าง if else ขึ้นมาเพื่อตรวจสอบถ้าเท่ากันให้ return true 
แต่ถ้าไม่เท่ากันให้ return false ในที่นี้ x1 และ x2 มี isbn เท่ากันคือ 123 เมื่อ console.log(isBookEqual(x1,x2)) จึงได้ค่าเป็น true

----------------------------------------------------------------------------------------------------------------------

const book1={isbn:123, title:"JS"}
const book2={isbn:123, title:"JS"}

const keys = Object.keys(book1) // array of keys // [ 'isbn', 'title' ]
const values = Object.values(book1) // array of values // [ 123, 'JS' ]

คำอธิบาย ตัวอย่างนี้เป็นการเรียกให้แสดงค่า keys และ values ของ Object book1 เมื่อ console.log(keys) ออกมาจะได้ผลลัพธ์
เป็น [ 'isbn', 'title' ] และ ถ้า console.log(values) จะได้ผลลัพธ์เป็น [ 123, 'JS' ]

-----------------------------------------------------------------------------------------------------------------------

//destructuring on array 
const colors = ["red", "green", "blue"]
const [, item2] = colors // const items = color[1]
console.log(item2)

คำอธิบาย const [, item2] = colors คือการใช้ array destructuring โดยใส่ , หนึ่งครั้งเพื่อ ข้าม index 0 ("red") 
ตัวแปร item2 จึงได้ค่าจาก index 1 ("green") เมื่อ console.log(item2) ออกมาจึงได้ผลลัพธ์เป็น green

-----------------------------------------------------------------------------------------------------------------------

const book3 = {isbn:1234, title:"JS", authors:{Firstname:"Jon", Lastname:"Smith"}}

const {isbn: BookISBN // การเปลี่ยนชื่อต้องใส่ Key ก่อนแล้วตามด้วย : และ ชื่อใหม่  
    , title} = book3
console.log(isbn)
console.log(title)

const {authors:{Firstname}} = book3
console.log(Firstname)

คำอธิบาย isbn: BookISBN หมายถึง การดึงค่า key isbn มาเก็บในตัวแปรชื่อใหม่คือ BookISBN และ{authors:{Firstname}} = book3
เป็นการเข้าถึง object authors ภายใน แล้วดึง key Firstname ออกมาโดยตรง ได้ค่าเป็น Jon

-------------------------------------------------------------------------------------------------------------------------

let q1 = {
    isbn: 123456789,
    title: "JavaScript"
}

let q2 = {
    isbn: 123456789,
    title: "JavaScript"
}

function shallowEquality(q1,q2) {
    const keys1 = Object.keys(q1)
    const keys2 = Object.keys(q2)

    if (keys1.length !== keys2.length) {
        return false
    }
    for (let key of keys1) {
        if (q1[key] !== q2[key]) {
            return false
        }
    }
    return true
}

คำอธิบาย เป็น function สำหรับตรวจสอบว่า object 2 ตัว มี key-value เท่ากันหรือไม่ ซึ่งใน function เขียน const keys1 = Object.keys(q1) และ
const keys2 = Object.keys(q2) หมายถึง Array ที่เก็บ keys ของ Object q1 และ q2 ไว้ ซึ่งได้เขียน if else ออกมาเพื่อ check ความเท่ากันดังนี้
keys1.length !== keys2.length หมายถึง ตรวจสอบจำนวน keys ของทั้ง 2 object ว่าเท่ากันหรือไม่ ถ้าไม่เท่ากันให้ return เป็น false
แต่ถ้าจำนวน keys เท่ากัน ก็จะมา check ใน for loop ต่อ if (q1[key] !== q2[key]) { return false } หมายถึง การตรวจสอบ values ของ keys ใน
object ว่าเท่ากันหรือไม่ ถ้าไม่เท่ากันให้ return false แต่ถ้าเท่ากันให้ return true เช่นในตัวอย่างเป็น 
[ isbn: 123456789, title: "JavaScript" ] เท่ากัน จึงได้ผลลัพธ์ออกมาเป็นค่า true

// practice

/*
1. Nested Object & Array
- Create an object employee
- Display the entire employee object
- Display the full name by combining first + last
- Display the second project ("ProjectB")
*/

const employee = { empId: 1001, name: { first: "Bob", last: "Marley" }, projects: ["ProjectA", "ProjectB", "ProjectC"] }
console.log(employee)
const fullname = employee.name.first + " " + employee.name.last
console.log(fullname)
console.log(employee.projects[1])

คำอธิบาย จากโจทย์ให้สร้าง Object employee ซึ่งมีค่า key เป็น empId name และ projects เมื่อ console.log ออกมาจะได้ค่าเป็น
{ empId: 1001, name: { first: 'Bob', last: 'Marley' }, projects: [ 'ProjectA', 'ProjectB', 'ProjectC' ] } ต่อมา
โจทย์บอกให้แสดงชื่อเต็มของ employee จึงกำหนด fullname ขึ้นมา เพื่อเก็บค่าชื่อเต็มจาก employee.name.first + " " + employee.name.last
เมื่อ console.log(fullname) จะได้ผลลัพธ์เป็น Bob Marley และสุดท้ายโจทย์ให้แสดงค่า projectB จึงเขียนคำสั่งเพื่อแสดงเป็น 
console.log(employee.projects[1])

--------------------------------------------------------------------------------------------------------------------------------

/*
2. Object with Array of Objects
- Create an object library
- Display the title of the first book
- Display the author of the second book
- Use Object.values() on the third book
*/

const library = { code: "LIB001", name: "City Library", books: [
    {title:"JS Basics", author:"Alice"},
    {title:"Python Intro", author:"Bob"},
    {title:"CSS Guide", author:"Carol"}
  ], isOpen: true }

console.log(library.books[0].title)
console.log(library.books[1].author)
console.log(Object.values(library.books[2]))

คำอธิบาย จากโจทย์ให้สร้าง Object library ซึ่งมีค่า key เป็น code name books และ isOpen เมื่อ console.log(library) จะได้ค่าเป็น
{ code: "LIB001", name: "City Library", books: [{title:"JS Basics", author:"Alice"}, {title:"Python Intro", author:"Bob"},
{title:"CSS Guide", author:"Carol"}], isOpen: true } โจทย์สั่งให้แสดง title ของ books ตัวแรก จึง console.log(library.books[0].title)
จะได้ผลลัพธ์เป็น JS Basics ต่อมาสั่งให้แสดง author ของ books ที่ 2 จึงใช้คำสั่ง console.log(library.books[1].author)
ได้ค่าเป็น Bob และสุดท้ายโจทย์สั่งให้แสดงค่า values ของ books ที่ 3 จึงใช้คำสั่ง console.log(Object.values(library.books[2]))
ได้ผลลัพธ์เป็น [ 'CSS Guide', 'Carol' ]

--------------------------------------------------------------------------------------------------------------------------------------

/*
3. Constructor Function + Method
- Create a Constructor Function Movie:
- Properties: name, year, actors (array)
- Method: getMovieInfo() returns "Name: xxx, Year: yyy, Actors: a,b,c"
- Create an instance: movie1 = "Inception", 2010, ["Leonardo", "Elliot"]
- Display movie1.getMovieInfo()
*/

function Movie(name, year, actors) {
    this.name = name
    this.year = year
    this.actors = actors
    this.getMovieInfo = function() {
        return `Name: ${this.name}, Year: ${this.year}, Actors: ${this.actors.join(", ")}`
    }
}

const movie1 = new Movie("Inception", 2010, ["Leonardo", "Elliot"])
console.log(movie1.getMovieInfo())

คำอธิบาย จากโจทย์ให้สร้าง Object แบบ constructor function ซึ่งตั้งชื่อ function ด้วย M ตัวใหญ่ และมีการใช้ this. คือ
constructor function ต่อมาโจทย์ให้สร้าง method getMovieInfo ไว้ด้านในด้วย เพื่อ return ข้อมูลของ Movie จึงเขียน Method เป็น
this.getMovieInfo = function() {
        return `Name: ${this.name}, Year: ${this.year}, Actors: ${this.actors.join(", ")}`
}
ต่อมา โจทย์ให้ create movie1 ที่มี values คือ "Inception", 2010, ["Leonardo", "Elliot"] เมื่อ console.log(movie1)
ออกมาจะได้เป็น Movie { name: 'Inception', year: 2010, actors: [ 'Leonardo', 'Elliot' ], getMovieInfo: [Function (anonymous)] }
ต่อมาโจทย์ให้แสดง getMovieInfo ของ movie1 จึงเขียน console.log(movie1.getMovieInfo()) ซึ่งได้ผลลัพธ์เป็น Name: Inception, Year: 2010, 
Actors: Leonardo, Elliot

--------------------------------------------------------------------------------------------------------------------------------------

/*
4. Class + Nested Property + Method
- Create a Class Movie:
- Constructor parameters: name, year, director (object {firstName, lastName})
- Method getDirector() returns director’s full name
- Method setYear(year) updates the year
- Create an instance: movie2 = "Avatar", 2009, {firstName:"James", lastName:"Cameron"}
- Display the director, update the year to 2022, display getMovieInfo()
*/

class Movie{
    constructor(name, year, director){
        this.name = name
        this.year = year
        this.director = director
    }
    getMovieInfo(){
        return `Name: ${this.name}, Year: ${this.year}, Director: ${this.director.firstName} ${this.director.lastName}`
    }
    getDirector(){
        return `${this.director.firstName} ${this.director.lastName}`
    }
    setYear(){
        this.year = year
    }
}

const movie2 = new Movie("Avatar", 2009, {firstName:"James", lastName:"Cameron"})
console.log(movie2.getDirector())
console.log(movie2.getMovieInfo())
movie2.setYear(2022)
console.log(movie2.getMovieInfo())

คำอธิบาย โจทย์ให้สร้าง Object จาก class Movie ซึ่งสร้าง class Movie ขึ้นมาก่อน ประกอบด้วย constructor และ method ต่าง ๆ 
เช่น constructor --> name, year, director และ method getMovieInfo() แสดงข้อมูล Movie getDirector() แสดงชื่อของ director
setYear() เป็น method ที่กำหนดปีของ Movie ซึ่งจากโจทย์ให้สร้าง Object movie2 ขึ้นมา และให้แสดงข้อมูลของ director จึงใช้คำสั่ง
console.log(movie2.getDirector()) ได้ผลลัพธ์เป็น Director: James Cameron และลองแสดงข้อมูลดูโดยใช้ console.log(movie2.getMovieInfo())
จะได้ค่าเป็น Movie info: Name: Avatar, Year: 2009, Director: James Cameron ต่อมาโจทย์ต้องการให้ set ปีของ movie2 เป็น 2022
จึงใช้ method setYear โดยใช้คำสั่ง movie2.setYear(2022) เมื่อ console.log(movie2.getMovieInfo()) ข้อมูลปีจะเปลี่ยนเป็นดังนี้
Updated Movie info: Name: Avatar, Year: 2022, Director: James Cameron

--------------------------------------------------------------------------------------------------------------------------------------

/*
6. Destructuring + Nested Array/Object
Given an array:
  {name:"cat", age:2},
  {name:"dog", age:5},
  {name:"rabbit", age:1}
Use destructuring to get the name of the second element ("dog") and the age of the first element 

Given an object:
const director = {name:{first:"Steven", last:"Spielberg"}, awards:["Oscar","Golden Globe"]}
Use destructuring to get first and the first award ("Oscar")
*/

const animals = [{ name:"cat", age:2 }, {name:"dog", age:5}, {name:"rabbit", age:1}]

const [, secondAnimal] = animals  
const { name: secondName } = secondAnimal
const { age: firstAge } = animals[0]

console.log(secondName)
console.log(firstAge)

const director = { 
    name: { first: "Steven", last: "Spielberg" }, 
    awards: ["Oscar", "Golden Globe"] 
}

const { name: { first: directorFirstName }, awards: [firstAward] } = director

console.log(directorFirstName)
console.log(firstAward)

คำอธิบาย สร้าง Array animals ขึ้นมา และใช้ Destructuring เพื่อแสดงค่า name ของตัวที่ 2 และ age ของตัวแรก โดยกำหนดให้
const [, secondAnimal] = animals คือการดึง secondAnimal จาก animals[1] และ const { age: firstAge } = animals[0]
เป็นการดึง firstAge จาก animals[0] เมื่อ console.log(secondName) และ console.log(firstAge) จะได้ผลลัพธ์ออกมาเป็น dog และ 2
ตามลำดับ ต่อมา สร้าง Object director ขึ้นมา และกำหนด const { name: { first: directorFirstName }, awards: [firstAward] } = director
คือการให้ดึง director.name.first จาก nested object คือ "Steven" และ director.awards[0] ดึง element แรกของ array คือ "Oscar"

-----------------------------------------------------------------------------------------------------------------------------------------
น.ส.ธันวาวีร์  นิธิพรชัยวงศ์ 67130500131
